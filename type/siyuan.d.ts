// Generated by dts-bundle v0.7.3

declare module 'siyuan' {
    import * as serverApi from 'siyuan/api/server-api';
    import * as clientApi from 'siyuan/api/client-api';
    import { Menu, MenuItem, MenuSeparator } from 'siyuan/internal/classes/menu';
    import { Dialog } from 'siyuan/internal/classes/dialog';
    import { Notification } from 'siyuan/internal/classes/notification';
    import { Plugin } from 'siyuan/api/plugin';
    export { clientApi, serverApi, Menu, MenuItem, MenuSeparator, Notification, Dialog, Plugin };
    const _default: {
        clientApi: typeof clientApi;
        serverApi: typeof serverApi;
        Plugin: typeof Plugin;
        Menu: typeof Menu;
        MenuItem: typeof MenuItem;
        MenuSeparator: typeof MenuSeparator;
        Notification: typeof Notification;
        Dialog: typeof Dialog;
    };
    export default _default;
}

declare module 'siyuan/api/server-api' {
    export function request(url: any, data: any): Promise<any>;
    export function parseBody(response: any): Promise<any>;
    export function transactions(protyle: any, transactions?: any[]): Promise<any>;
    export function sql(sql: any): Promise<any>;
    export function lsNotebooks(sql: any): Promise<any>;
    export function getAnchor(anchorText: any, name: any): Promise<string>;
    export function openNotebook(notebookId: any): Promise<any>;
    export function closeNotebook(notebookId: any): Promise<any>;
    export function renameNotebook(notebookId: any, notebookNewName: any): Promise<any>;
    export function createNotebook(notebookName: any): Promise<any>;
    export function removeNotebook(notebookId: any): Promise<any>;
    export function getNotebookConf(notebookId: any): Promise<any>;
    export function setNotebookConf(notebookId: any): Promise<any>;
    export function renameDoc(notebookId: any, path: any, title: any): Promise<any>;
    export function removeDoc(notebookId: any, path: any): Promise<any>;
    export function moveDoc(srcNotebookId: any, srcPath: any, targetNotebookId: any, targetPath: any): Promise<any>;
    export function getHPathByPath(notebookId: any, path: any): Promise<any>;
    export function getHPathByID(ID: any): Promise<any>;
    export function getBlockAttrs(blockId: any): Promise<any>;
    export function getBlockByID(blockId: any): Promise<any>;
    export function getBlockKramdown(blockId: any): Promise<any>;
    export function getBlockBreadcrumb(ID: any): Promise<any>;
    export function setBlockAttrs(blockId: any, attrs: any): Promise<any>;
    export function exportMdContent(docId: any): Promise<any>;
    export function getDocOutline(docId: any): Promise<any>;
    export function listDocsByPath(path: any): Promise<any>;
    export function getBacklink(id: any): Promise<any>;
    export function searchEmbedBlock(excludeIds: any, sql: any): Promise<any>;
    export function getDoc(id: any): Promise<any>;
    export function getFocusedDoc(id: any): Promise<any>;
    export function getTag(): Promise<any>;
    export function getLocalGraph(k: any, id: any, conf: any, reqId: any): Promise<any>;
    export function getGraph(k: any, conf: any, reqId: any): Promise<any>;
    export function searchDocs(k: any): Promise<any>;
    export function searchBlock(query: any): Promise<any>;
    export function searchTemplate(k: any): Promise<any>;
    export function createDocWithMd(notebook: any, path: any, markdown: any): Promise<any>;
    export function docSaveAsTemplate(id: any, overwrite?: boolean): Promise<any>;
    export function render(data: any): Promise<any>;
    export function insertBlock(previousID: any, dataType: any, data: any): Promise<any>;
    export function prependBlock(parentID: any, dataType: any, data: any): Promise<any>;
    export function appendBlock(parentID: any, dataType: any, data: any): Promise<any>;
    export function updateBlock(id: any, dataType: any, data: any): Promise<any>;
    export function deleteBlock(id: any): Promise<any>;
    export function moveBlock(id: string, previousID: string, parentID: string): Promise<any>;
    export function getSysFonts(): Promise<any>;
    export function getFile(path: string, type?: 'json' | 'text'): Promise<any>;
    export function putFile(path: any, filedata: any, isDir?: boolean, modTime?: number): Promise<any>;
    export function readDir(path: string): Promise<any>;
    export function removeFile(path: any): Promise<any>;
    export function pushMsg(message?: any, text?: any, timeout?: number): Promise<any>;
    export function pushErrMsg(message?: any, text?: any, timeout?: number): Promise<any>;
    export function setStorageVal(key: string, val: any): Promise<any>;
    export function getLocalStorage(): Promise<any>;
    export function renderSprig(template: string): Promise<any>;
    export function getBazzarWidget(): Promise<any>;
}

declare module 'siyuan/api/client-api' {
    export function addToolbarLeft(el: Element): void;
    export function addToolbarRight(el: Element): void;
    export const createLogger: (name: string) => import("zhi-log").DefaultLogger;
}

declare module 'siyuan/internal/classes/menu' {
    export interface IMenuItemOption {
        label?: string;
        click?: (element: HTMLElement) => void;
        type?: 'separator' | 'submenu' | 'readonly';
        accelerator?: string;
        action?: string;
        id?: string;
        submenu?: IMenuItemOption[];
        disabled?: boolean;
        icon?: string;
        iconHTML?: string;
        current?: boolean;
        bind?: (element: HTMLElement) => void;
    }
    export class Menu {
        constructor(id: string);
        addItem(item: MenuItem): this;
        addSeparator(): this;
        showAtMouseEvent(event: MouseEvent): this;
        showAtPosition(position: {
            x: number;
            y: number;
        }): this;
        close(): void;
    }
    /**
      * Copy from siyuan source code
      */
    export class MenuItem {
        element: HTMLElement;
        constructor(options: IMenuItemOption);
    }
    export class MenuSeparator {
    }
}

declare module 'siyuan/internal/classes/dialog' {
    export class Dialog {
        element: HTMLElement;
        constructor(options: {
            title?: string;
            transparent?: boolean;
            content: string;
            width?: string;
            height?: string;
            destroyCallback?: () => void;
            disableClose?: boolean;
            disableAnimation?: boolean;
        });
        static destroyAll(): void;
        destroy(): void;
        bindInput(inputElement: HTMLInputElement | HTMLTextAreaElement, enterEvent?: () => void): void;
    }
}

declare module 'siyuan/internal/classes/notification' {
    import { INoticationOption, INotification } from 'siyuan/types';
    export class Notification implements INotification {
        constructor(option: INoticationOption);
        show(): void;
    }
}

declare module 'siyuan/api/plugin' {
    import { IPlugin, IPluginCommand, SettingRender } from 'siyuan/types';
    export class Plugin implements IPlugin {
        _id: string;
        onload(): void;
        onunload(): void;
        registerCommand(command: IPluginCommand): void;
        registerSettingRender(settingRender: SettingRender): void;
        loadStorage(filename: string): Promise<any>;
        writeStorage(filename: string, content: any): Promise<void>;
    }
}

declare module 'siyuan/types' {
    export interface IPlugin {
        onload(): void;
        onunload(): void;
        registerCommand(command: IPluginCommand): any;
        registerSettingRender(settingRender: SettingRender): any;
        loadStorage(filename: string): Promise<Response>;
        writeStorage(filename: string, content: any): Promise<void>;
    }
    export interface PluginConstructor {
        new (): IPlugin;
    }
    export interface StorePluginManifest {
        key: string;
        name: string;
        description: string;
        author: string;
        version: string;
        url: string;
    }
    export interface StorePluginStatus extends StorePluginManifest {
        isExist: boolean;
        needUpgrade: boolean;
    }
    export interface PluginManifest {
        key: string;
        name: string;
        version: string;
        script?: string;
        enabled?: boolean;
        hidden?: boolean;
        description?: string;
        url?: string;
        author?: string;
        plugin?: new (...args: any) => IPlugin;
    }
    export interface IStorageManager {
        get(key: keyof PluginConfig): any;
        set(key: string, val: any): Promise<void>;
        initStorage(): Promise<IStorageManager>;
        getPlugins(): PluginManifest[];
        getInternalPlugins(): PluginManifest[];
        getThirdPartyPlugins(): PluginManifest[];
        getPluginByKey(key: string): PluginManifest | undefined;
        setPluginEnabled(key: string, enabled: boolean): Promise<void>;
        savePluginsEnabled(): Promise<void>;
        setSafeModeEnabled(enabled: boolean): Promise<void>;
        setPluginStorage(pluginKey: string, filename: string, content: any): Promise<void>;
        getPluginStorage(pluginKey: string, filename: string): Promise<Response>;
        uninstallPlugin(key: string): Promise<void>;
    }
    export interface ISystemManager {
        saveToLocal(p: string, content: string): Promise<void>;
        localCacheInit(): Promise<void>;
        delayAutoUpgrade(): void;
        tryUpgrade(): Promise<void>;
        getOnlineVersion(): Promise<string>;
        upgrade(): Promise<void>;
    }
    export interface IPluginSystem {
        init(): Promise<IPluginSystem>;
        loadPlugin(key: string): Promise<void>;
        unloadPlugin(key: string): Promise<void>;
        turnOffSafeMode(): Promise<void>;
        turnOnSafeMode(): Promise<void>;
    }
    export interface IPluginLoader {
        loadEnabledPlugins(plugins: PluginManifest[]): Promise<void>;
        loadAllInternalPlugins(): Promise<void>;
        loadAllLocalPlugins(): Promise<void>;
        loadPlugin(plugin: PluginManifest): Promise<void>;
        unloadPlugin(key: string): Promise<void>;
        generateRequiredModules(): void;
        unloadThirdPartyPlugins(plugins: PluginManifest[]): Promise<void>;
        loadThirdPartyEnabledPlugins(plugins: PluginManifest[]): Promise<void>;
    }
    export interface IPluginFileManager {
        scanPlugins(pluginFolder: string): Promise<string[]>;
        getFileContent(f: string): Promise<string>;
        getManifest(f: string): Promise<any>;
        getScript(f: string): Promise<string>;
        getAllPlugins(): Promise<PluginManifest[]>;
    }
    export interface ISettingTab {
        key: string;
        name: string;
        settings: ISetting[];
    }
    export interface ISetting<T extends ISettingType = any> {
        key: string;
        name: string;
        type: T;
        value: T extends 'boolean' ? boolean : T extends 'string' ? string : T extends 'array' ? Array<any> : T extends 'number' ? number : any;
    }
    export enum ISettingType {
        BOOLEAN = "boolean",
        STRING = "string",
        ARRAY = "array",
        NUMBER = "number"
    }
    export interface PluginEnableConfig {
        key: string;
        enabled: boolean;
    }
    export interface PluginConfig {
        PLUGIN_SYSTEM_SAFE_MODE_ENABLED: boolean;
        PLUGIN_SYSTEM_AUTO_UPDATE: boolean;
        PLUGIN_SYSTEM_PLUGIN: Array<PluginEnableConfig>;
        PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN: Array<PluginEnableConfig>;
        PLUGIN_STORE_URL: string;
    }
    export type Listener = (...args: any) => void;
    export interface IEventBus {
        on(eventName: string, callback: Listener): () => void;
        off(eventName: string, callback?: Listener): void;
        emit(eventName: string, ...args: any): void;
        destroy(): void;
    }
    export interface Command {
        plugin: string;
        pluginName: string;
        command: string;
        shortcut?: string;
        description?: string;
        callback: (...args: any[]) => any;
    }
    export interface IPluginCommand {
        command: string;
        shortcut?: string;
        description?: string;
        callback: (...args: any[]) => any;
    }
    export interface ICommandManager {
        registerCommand(command: Command): any;
        unregisterCommand(command: Command): any;
        unregisterCommandByPlugin(plugin: string): any;
        getCommands(): Command[];
    }
    export interface IShortcut {
        registerKeyboardEvent(shortcut: string, callback: (e: KeyboardEvent) => void): any;
        unregisterKeyboardEvent(shortcut: string): any;
        registerKeyboardEventFromPlugin(command: Command): any;
        unregisterKeyboardEventFromPlugin(command: Command): any;
    }
    export interface INotification {
        show(): void;
    }
    export interface INoticationOption {
        type: 'error' | 'info';
        message: string;
        timeout?: number;
    }
    export interface IStore {
        init(): Promise<void>;
        getStoreUrl(): string;
        getPlugins(): StorePluginManifest[];
        loadPlugins(): Promise<StorePluginManifest[]>;
        getPluginsWithStatus(): StorePluginManifest[];
        loadPluginsFromUrl(): Promise<void>;
        getPluginByUrl(url: string): Promise<{
            manifest: string;
            mainJs: string;
        }>;
        getPluginManifest(url: string): Promise<PluginManifest>;
        getPluginReadme(url: string): Promise<string>;
        downloadPlugin(key: string): Promise<any>;
    }
    export type SettingRender = (element: HTMLElement) => void;
    export interface ISettingManager {
        registerSetting(key: string, settingRender: SettingRender): void;
        unregisterSetting(key: string): void;
        getSettingRenders(): Array<{
            key: string;
            value: SettingRender;
        }>;
    }
}

